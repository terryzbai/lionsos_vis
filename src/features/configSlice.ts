import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit'
import { RootState } from '../app/store'

export interface VMState {
  name: string
  id: number
  priority: number
}

export interface PDState {
  id: string,
  name: string
  priority: number
  budge: number
  period: number
  pp: number
  prog_img: string
  mappings: string[]
  pds: string[]
  vms: string[]
  parent: string
}

export interface MRState {
  name: string
  phy_addr: number
  size: number
  page_size: number
}

export interface CCState {
  id: string
  end1: string
  end2: string
}


export interface ConfigState {
  mrs: MRState[]
  pds: PDState[]
  ccs: CCState[]
  graph: PDState[]
  nodeEditorVisible: boolean
}

const initialState: ConfigState = {
  mrs: [],
  pds: [],
  ccs: [],
  graph: [],
  nodeEditorVisible: false
}

export const configSlice = createSlice({
  name: 'component',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    addPD: (state, action: PayloadAction<string>) => {
      const new_pd : PDState = {
        id: action.payload,
        name: 'Untitled PD',
        priority: 0,
        budge: 0,
        period: 0,
        pp: 0,
        prog_img: '',
        mappings: [],
        pds: [],
        vms: [],
        parent: '',
      }
      state.pds.push(new_pd)
      console.log("Add a pd")
    },
    openNodeEditor: (state, action: PayloadAction<string>) => {
      console.log(action.payload)
      state.nodeEditorVisible = true
    },
    closeNodeEditor: (state) => {
      state.nodeEditorVisible = false
    }
    // increment: state => {
    //   // Redux Toolkit allows us to write "mutating" logic in reducers. It
    //   // doesn't actually mutate the state because it uses the Immer library,
    //   // which detects changes to a "draft state" and produces a brand new
    //   // immutable state based off those changes
    //   state.value += 1
    // },
    // decrement: state => {
    //   state.value -= 1
    // },
    // // Use the PayloadAction type to declare the contents of `action.payload`
    // incrementByAmount: (state, action: PayloadAction<number>) => {
    //   state.value += action.payload
    // }
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  // extraReducers: builder => {
  //   builder
  //     .addCase(incrementAsync.pending, state => {
  //       state.status = 'loading'
  //     })
  //     .addCase(incrementAsync.fulfilled, (state, action) => {
  //       state.status = 'idle'
  //       state.value += action.payload
  //     })
  //     .addCase(incrementAsync.rejected, state => {
  //       state.status = 'failed'
  //     })
  // }
})

export const { addPD, openNodeEditor, closeNodeEditor } = configSlice.actions

export const getPDList = (state: RootState) => state.config.pds
export const getNodeEditorStatus = (state: RootState) => state.config.nodeEditorVisible
export const getPDInfo = (state: RootState, node_id: string) => {
  return state.config.pds[0]
}

export default configSlice.reducer