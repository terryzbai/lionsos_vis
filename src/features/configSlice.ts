import { createAsyncThunk, createSlice, isAction, PayloadAction } from '@reduxjs/toolkit'
import { store, RootState } from '../app/store'
import { init_node_data } from '../components/nodes'

export interface VMState {
  name: string
  id: number
  priority: number
}

export interface PDState {
  id: string,
  name: string
  priority: number
  budget: number
  period: number
  pp: number
  prog_img: string
  mappings: string[]
  pds: string[]
  vms: string[]
  parent: string
}

export interface MRState {
  name: string
  phy_addr: number
  size: number
  page_size: number
}

export interface CCState {
  id: string
  end1: string
  end2: string
}

export interface NodeEditorState {
  visible: boolean
  node_id: string
}

export interface ConfigState {
  mrs: MRState[]
  pds: PDState[]
  ccs: CCState[]
  graph: PDState[]
  nodeEditor: NodeEditorState
}


const initialState: ConfigState = {
  mrs: [],
  pds: [],
  ccs: [],
  graph: [],
  nodeEditor: {
    visible: false,
    node_id: ''
  }
}

export const configSlice = createSlice({
  name: 'component',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    addNodeIntoList: (state, action: PayloadAction<{id: string, shape: string}>) => {
      const new_pd : PDState = {
        id: action.payload.id,
        ...init_node_data[action.payload.shape]
      }
      state.pds.push(new_pd)
      console.log("Add a", action.payload.shape, action.payload.id)
    },
    openNodeEditor: (state, action: PayloadAction<string>) => {
      state.nodeEditor.visible = true
      state.nodeEditor.node_id = action.payload
    },
    closeNodeEditor: (state) => {
      state.nodeEditor.visible = false
    },
    updateNode: (state, action: PayloadAction<PDState>) => {
      const newNodeData = action.payload
      const oldNode = state.pds.find(pd => pd.id === newNodeData.id)
      const index = state.pds.indexOf(oldNode)
      if (index >= 0) {
        // state.pds[index].name = newNodeData.name
        state.pds[index].name = newNodeData.name
        state.pds[index].priority = newNodeData.priority
        state.pds[index].budget = newNodeData.budget
        state.pds[index].period = newNodeData.period
        state.pds[index].pp = newNodeData.pp
        state.pds[index].prog_img = newNodeData.prog_img
      } else {
        console.log("Invalid node_id")
      }

      // List all nodes

      // Update label
      // graph_node.attr('label/text', newNodeData.name)
    },
    deleteNode: (state, action: PayloadAction<string>) => {
      const node_id = action.payload
      const nodeToDelete = state.pds.find(pd => pd.id === node_id)
      const index = state.pds.indexOf(nodeToDelete)
      if (index >= 0) {
        delete state.pds[index]
        state.pds.splice(index, 1)
      } else {
        console.log("Invalid node_id to delete")
      }
    }
    // increment: state => {
    //   // Redux Toolkit allows us to write "mutating" logic in reducers. It
    //   // doesn't actually mutate the state because it uses the Immer library,
    //   // which detects changes to a "draft state" and produces a brand new
    //   // immutable state based off those changes
    //   state.value += 1
    // },
    // decrement: state => {
    //   state.value -= 1
    // },
    // // Use the PayloadAction type to declare the contents of `action.payload`
    // incrementByAmount: (state, action: PayloadAction<number>) => {
    //   state.value += action.payload
    // }
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  // extraReducers: builder => {
  //   builder
  //     .addCase(incrementAsync.pending, state => {
  //       state.status = 'loading'
  //     })
  //     .addCase(incrementAsync.fulfilled, (state, action) => {
  //       state.status = 'idle'
  //       state.value += action.payload
  //     })
  //     .addCase(incrementAsync.rejected, state => {
  //       state.status = 'failed'
  //     })
  // }
})

export const { addNodeIntoList, openNodeEditor, closeNodeEditor, updateNode, deleteNode } = configSlice.actions

export const getPDList = (state: RootState) => state.config.pds
export const getNodeEditorStatus = (state: RootState) => state.config.nodeEditor.visible
export const getCurrentPD = (state: RootState) => {
  return state.config.pds.find(pd => pd.id === state.config.nodeEditor.node_id)
}

export const getSDFContent = (state: RootState) => {
  console.log("Get current pds: ", state.config.pds)
  const pds_content = state.config.pds.map((pd) => {
    if (pd.parent == "") {
      let attrs = ''
      attrs += pd.name ? ` name="${pd.name}"` : ''
      attrs += pd.priority ? ` priority="${pd.priority}"` : ''
      attrs += pd.budget ? ` budget="${pd.budget}"` : ''
      return `\t<protection_domain${attrs}>\n\t</protection_domain>`
    }
    return ''
  })
  const content = '<?xml version="1.0" encoding="UTF-8"?>\n<system>\n' + pds_content.join('\n') + "\n</system>"
  console.log(content)
  return content
}

// export const incrementIfOdd =
//   (amount: number): AppThunk =>
//   (dispatch, getState) => {
//     const currentValue = selectCount(getState())
//     if (currentValue % 2 === 1) {
//       dispatch(incrementByAmount(amount))
//     }
//   }

export default configSlice.reducer